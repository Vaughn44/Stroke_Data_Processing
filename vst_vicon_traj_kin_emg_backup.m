%% VST Experiment Post-processing
%(Combine VST-Vicon datasets)
% Author: Chrysostomos Karakasis (2021)

%Description:
% This code combines the two files generated by the Vicon Nexus in the Windows
% PC (Venus) and the VST Architecture in the Linux PC (Mercury). The user
% has to specify the location of each file. The two files are synchronized
% based on the 3D-position of the left heel marker. The offset
% between the two "frames" counters is derived and both files are truncated
% in order to have the the same starting frame and duration. Missing data
% associated with missing frames in the VST file are filled using a linear
% interpolation. Specific column data such as treadmill speed, desired
% stiffness, etc. are integrated to the data generated by the Vicon Nexus.
% The resulting file is stored in the same folder as this code.
subs= {'N'}';
for I= 1:length(subs)
    
clearvars -except subs I
close all;
clc

%%%%%% Vaughn's thoughts %%%%%%%%
% Need these 4 files in a folder called "Subject_Name" (example: "Subject 5")
% vst_file= 'vst_output.txt';   (vst data)
% traj_file= 'traj.csv';        (marker data)
% kin_file= 'kin.csv';          (kinematic data from model output)
% emg_file= 'emg.csv';          (emg data)
%%%
% 2 files will be added to the folder upon running this code: the marker
% data & kinematic data in 1 table, & the emg data in another table

% Description of the VST Data Columns:
% Column 1:     Time stamp                                  (sec)
% Column 2:     Treadmill Speed PWM Value                   (0-255)
% Column 3:     Treadmill Speed                             (cm/s)
% Column 4:     (Sent) Desired Position of Linear Track     (cm)
% Column 5:     Current Position of Linear Track            (cm)
% Column 6:     Treadmill's Inclination Angle               (deg)
% Column 7:     Boolean value for experiment                (0/1)
% Column 8:     Frame Number                                (integer)
% Column 9:     X coordinate of Left Heel Marker            (mm)
% Column 10:    Y coordinate of Left Heel Marker            (mm)
% Column 11:    Z coordinate of Left Heel Marker            (mm)
% Column 12:    Gait Cycle Counter                          (integer)
% Column 13:    Frame of Last Heel-Strike Event             (integer)
% Column 14:    Desired Stiffness of Treadmill              (N/m)
% Column 15:    (Raw) Desired Position of Linear Track      (cm)

% Column 4 has the values of the desired position of the linear track that
% were actually sent to the linear track. Column 15 has the raw value of
% the desired position of the linear track as they are calculated. However,
% if the values are less than 0 or higher than 38, e.g. Inf, they won't be
% sent to the linear track. Column 15 is for debugging purposes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%0
%% Define input and output files
% Specify the desired name of the final output file
subject= ['Subject ' subs{I}];
output_file_name = 'traj_kin_unif.csv';
output_file_name_emg = 'emg_unif.csv';
folder= ['Data/' subject];
vst_file= 'output.txt';
traj_file= 'traj.csv';
kin_file= 'kin.csv';
emg_file= 'emg.csv';
% Load the file generated from the VST architecture
input_file = [folder '/' vst_file];
vst_data = load(input_file);
% Load the file generated from the Vicon Nexus
% vicon_data = readtable('C:\Users\chryskar\Documents\Delaware Research\VST Architecture\Unify VST and Vicon Data\Test_1_Vaughn_4_12_2021\Test1_vicon_motion_capture.csv');
traj_data = readtable([folder '/' traj_file]);
kin_data= readtable([folder '/' kin_file]);
kin_data= kin_data(:,3:end);
emg_data= readtable([folder '/' emg_file]);
% labels_kin= {'LKNE_R' 'X1' 'LANK_RX' 'LANK_RY' 'LANK_RZ' 'RKNE_R' 'X2' 'RANK_RX' 'RANK_RY' 'RANK_RZ' 'LHIP_RX' 'LHIP_RY' 'LHIP_RZ' 'RHIP_RX' 'RHIP_RY' 'RHIP_RZ' 'WORLDROOT_RX' 'WORLDROOT_RY' 'WORLDROOT_RZ' 'WORLDROOT_TX' 'WORLDROOT_TY' 'WORLDROOT_TZ'};
labels_kin= {'LANK_ABSRX' 'LANK_ABSRY' 'LANK_ABSRZ' 'LANK_RX' 'LANK_RY' 'LANK_RZ' 'LFOOT_PROX' 'LFOOT_PROY' 'LFOOT_PROZ' 'LHIP_RX' 'LHIP_RY' 'LHIP_RZ' 'LKNE_RX' 'LKNE_RY' 'LKNE_RZ' 'LPEL_RX' 'LPEL_RY' 'LPEL_RZ' 'RANK_ABSRX' 'RANK_ABSRY' 'RANK_ABSRZ' 'RANK_RX' 'RANK_RY' 'RANK_RZ' 'RFOOT_PROX' 'RFOOT_PROY' 'RFOOT_PROZ' 'RHIP_RX' 'RHIP_RY' 'RHIP_RZ' 'RKNE_RX' 'RKNE_RY' 'RKNE_RZ' 'RPEL_RX' 'RPEL_RY' 'RPEL_RZ'};
kin_data.Properties.VariableNames = labels_kin(1,:);
% kin_data= kin_data(3:end,:);
vicon_data= [traj_data kin_data];
% vicon_data = readtable('C:\Users\chryskar\Documents\Delaware Research\VST Architecture\Unify VST and Vicon Data\Test_3_Vaughn_4_22_21\Trial01.csv');

%% Figure out the frame offset between Vicon and VST datasets
% Convert Vicon data to double format
vicon_frames = str2double(vicon_data.Var1(3:end));
% Remove duplicates by identifying unique instances of the Frame Number Column
[vst_frames,vst_frames_ind] = unique(vst_data(:,8),'stable');

% Remove inconsistent values at the start of the frames column
if (vst_frames(1) < vst_frames(2)-20) % Sometimes the first frame value is arbitrary
    vst_frames = vst_frames(2:end);
    vst_frames_ind = vst_frames_ind(2:end);
end
% Remove the duplicate data entries
vst_data_unique = vst_data(vst_frames_ind,:);

% Remove frame offset in order for the frame counter to start from 1
first_vst_frame = vst_frames(1);
vst_frames = vst_frames-vst_frames(1)+1;

% Identify the number of missing frames in the VST data and report
% the corresponding percentage to the total number of frames sent
missing_frames_vst = vst_frames(end)-length(vst_frames)
missing_frames_vst_perc = missing_frames_vst/vst_frames(end)

% Vicon's decimal accuracy ranges from 4 to 6 decimals. So far, we have not
% understood the reason behind this. We wish to compare the two data
% files, based on the 3D position signals of the left heel marker.
% Since, the decimal accuracy cannot be determined yet, we round data to
% fixed number of decimals starting from 5, and we keep decreasing it,
% until we have identified matching data pairs in both datasets.
d_p_a = 5;
while(1)
    % 3D-position signals of the left heel marker in the Vicon dataset
    lhee_x_vicon = round(str2double(vicon_data(3:end,33).Variables),d_p_a);
    lhee_y_vicon = round(str2double(vicon_data.Var34(3:end)),d_p_a);
    lhee_z_vicon = round(str2double(vicon_data.Var35(3:end)),d_p_a);
    lhee_vicon = [lhee_x_vicon lhee_y_vicon lhee_z_vicon];
    
    % Append missing frames with NaN
    vst_data_nan = nan(vst_frames(end),size(vst_data_unique,2));
    vst_data_nan(vst_frames,:) = vst_data_unique;
    
    % 3D-position signals of the left heel marker in the VST dataset
    lhee_x_vst = round(vst_data_nan(:,9),d_p_a);
    lhee_y_vst = round(vst_data_nan(:,10),d_p_a);
    lhee_z_vst = round(vst_data_nan(:,11),d_p_a);
    lhee_vst = [lhee_x_vst lhee_y_vst lhee_z_vst];
    
    % Identify all values of the three VST signals that exist also in the Vicon dataset
    % Basically, we want to find frames where the the 3D position of the left
    % heel marker is the same for both the VST and the Vicon dataset
    frames_match_vicon_vst = [];
    for i = 1:size(lhee_vst,1)
        potential_match = find( lhee_x_vicon == lhee_x_vst(i) );
        if ~isempty(potential_match)
            for g = 1:length(potential_match)
                if lhee_vicon(potential_match(g),2:3) == lhee_vst(i,2:3) % Check other two coordinates
                    frames_match_vicon_vst = [frames_match_vicon_vst; potential_match(g) i];
                end
            end
        end
    end
    if isempty(frames_match_vicon_vst)
        d_p_a = d_p_a - 1; % Reduce decimal points utilized for comparison
    else
        % Calculate the offset between matches
        frames_match_vicon_vst(:,3) = frames_match_vicon_vst(:,1) - frames_match_vicon_vst(:,2);
        not_same = find(frames_match_vicon_vst(:,3) ~= frames_match_vicon_vst(1,3));
        same = find(frames_match_vicon_vst(:,3) == frames_match_vicon_vst(1,3));
        if size(not_same,1) < size(same,1)
            frames_offset_ind = frames_match_vicon_vst(same(1),3);
        else
            frames_offset_ind = frames_match_vicon_vst(not_same(1),3);
        end
        break;
    end
end
% Now we know that there are data frames that exist in both the Vicon and
% the VST data. The vector "frames_match_vicon_vst(:,1)" contains the
% indices of the Vicon dataset, while "frames_match_vicon_vst(:,2)"
% contains the corresponding indices of the VST dataset.
% Hence, for example vst_frames(frames_match_vicon_vst(:,2)) (normalized) 
% or vst_data_nan(frames_match_vicon_vst(:,2),8) (raw) correspond
% to the vicon_frames(frames_match_vicon_vst(:,1)). For verification, check
% that lhee_z_vicon(frames_match_vicon_vst(1,1)) is equal to lhee_z_vst(frames_match_vicon_vst(1,2))
% frames_offset_ind is the offset between the indices of the two
% datasets

% Notice that vicon_frames(frames_match_vicon_vst(:,1)) == frames_match_vicon_vst(:,1)
% isequal(frames_match_vicon_vst(:,1),vicon_frames(frames_match_vicon_vst(:,1)))

if frames_offset_ind > 0 % Check whether Vicon recording started before the VST recording
    % Derive the first common frame of both datasets
    start_frame = frames_offset_ind + 1; 
    % Derive the last common frame of both datasets
    end_frame = min(vicon_frames(end),frames_offset_ind + size(vst_data_nan,1));
    % vst_frames(end) is the normalized last Vicon frame received on the VST side
    
    % Truncate the Vicon frame number column to the above interval
    frames_sync_vicon = vicon_frames(start_frame:end_frame);
    % Truncate the VST data to the above interval
    data_sync_vst = vst_data_nan(1:end_frame-frames_offset_ind,:);
else % Check whether Vicon recording started after the VST recording
    frames_offset_ind = -frames_offset_ind;
    
    % Derive the first common frame of both datasets
    start_frame = frames_offset_ind + 1;
    % Derive the last common frame of both datasets
%     end_frame = min(length(lhee_z_vicon(start_frame:end)), vst_frames(end) );
    end_frame = min(vicon_frames(end),frames_offset_ind + size(vst_data_nan,1));

    % Truncate the Vicon frame number column to the above interval
%     frames_sync_vst = vst_frames(start_frame:start_frame+end_frame-1);
%     frames_sync_vicon = vicon_frames(vicon_frames <= end_frame);
    frames_sync_vicon = vicon_frames(start_frame:end_frame);
    % Truncate the VST data to the above interval
    data_sync_vst = vst_data_nan(1:end_frame-frames_offset_ind,:);
end
frames_sync_emg= ((start_frame-1)*20+3:(end_frame)*20+2)';

%% Truncation of Data
% The truncated and synchronized version of the Vicon data
vicon_data_sync = [vicon_data(1:2,:); vicon_data(frames_sync_vicon+2,:)];
emg_data_sync = [emg_data(1:2,:); emg_data(frames_sync_emg,:)];

% The truncated and synchronized version of the VST data
vst_data_sync_nan = data_sync_vst;
% vst_data_nan = nan(size(frames_sync_vst,1),size(vst_data_unique,2));
% vst_data_nan(frames_sync_vst,:) = vst_data_unique((vst_frames <= end_frame-frames_offset),:);

% Now vst_data_nan contains the vst data synchronized with the Vicon data,
% with NaN values for the lines where frames are missing
vst_data_nan;

%% Interpolation
% We will use interpolation to replace all NaN values for any missing frames
% 'Nearest' interpolation for the integer valued columns (2 3 7 8 12 13 14)
vst_data_spline(:,[2 3 7 12 13 14]) = fillmissing(vst_data_sync_nan(:,[2 3 7 12 13 14]),'nearest');
% 'Spline' interpolation for the double valued columns (1 4 5 6 9 10 11)
vst_data_spline(:,[1 4 5 6 8 9 10 11 15]) = fillmissing(vst_data_sync_nan(:,[1 4 5 6 8 9 10 11 15]),'spline');

% Remove offset from VST frames and last-heel-strike-frames (Normalization)
vst_data_spline(:,8) = vst_data_spline(:,8) - vst_data_spline(1,8) + 1;
vst_data_spline(:,13) = vst_data_spline(:,13) - first_vst_frame + 1;
% Sometimes, the first value in the last-heel-strike-frames column
% corresponds to previous trials and should be disregarded
vst_data_spline(vst_data_spline(:,13)<0,13) = 1;

% Remove offset from Vicon frames
vicon_frames_final = str2double(vicon_data_sync.Var1(3:end))-str2double(vicon_data_sync.Var1(3))+1;
vicon_data_sync.Var1(3:end) = cellstr(num2str(vicon_frames_final));
emg_frames_final = str2double(emg_data_sync.Var1(3:end))-str2double(emg_data_sync.Var1(3))+1;
emg_data_sync.Var1(3:end) = cellstr(num2str(emg_frames_final));

% Final Version of synchronized data
vst_data_final = vst_data_spline;
vicon_data_final = vicon_data_sync;
emg_data_final = emg_data_sync;

% Now, we will append the VST data to the Vicon data
vst_vicon_data = vicon_data_final;
return
%% Check for errors in the heel-strike detection
lhee_sag = str2double(vst_vicon_data.Var34(3:end)); 
lhee_vert = str2double(vst_vicon_data.Var35(3:end));
frames = str2double(vst_vicon_data.Var1(3:end));
rhee_sag = str2double(vst_vicon_data.Var58(3:end)); 
rhee_vert = str2double(vst_vicon_data.Var59(3:end));

% Run F-VESPA offline on the Vicon Data
offline_heel_strikes = fvespa(lhee_vert,lhee_sag,frames);
right_heel_strikes = fvespa(rhee_vert,rhee_sag,frames);
RHSs= right_heel_strikes';

% Remove any duplicates from the Linux-VST heel-strikes recorded during the
% trial (online F-VESPA)
[real_time_heel_strikes,r_t_h_s_ind] = unique(vst_data_final(:,13),'stable');
% Remove first one which is not valid
real_time_heel_strikes = real_time_heel_strikes(2:end);
r_t_h_s_ind = r_t_h_s_ind(2:end);

if length(offline_heel_strikes)>length(real_time_heel_strikes)
    real_time_heel_strikes = [real_time_heel_strikes; offline_heel_strikes(end)];
end

% diff_hs_off_on = real_time_heel_strikes - offline_heel_strikes';
diff_hs_off_on = zeros(length(offline_heel_strikes),1)-offline_heel_strikes'; % Don't normally need
mismatch_hs_off_on = find(diff_hs_off_on ~=0);    

% Go through all gait cycles that have different heel-strike event times 
% between the offline and online version of F-VESPA
for i = 1:size(mismatch_hs_off_on)
    wanted_line = r_t_h_s_ind(mismatch_hs_off_on(i));
    % If the given gait cycle corresponds to a perturbation 
    if (vst_data_final(wanted_line,14) ~= 1000000) 
        % Update the heel-strike event time with the offline estimate
        temp = find( vst_data_final(:,13) == real_time_heel_strikes(mismatch_hs_off_on(i)) );
        vst_data_final(temp,13) = offline_heel_strikes(mismatch_hs_off_on(i)); 
    end
end

%% Unify the final and synchronized versions of the Vicon and VST datasets
% At this point we will decide which data (columns) from the VST data we
% wish to keep
% Column 3:     Treadmill Speed                     (cm/s)
% Column 4:     Desired Position of Linear Track    (cm)
% Column 5:     Current Position of Linear Track    (cm)
% Column 6:     Treadmill's Inclination Angle       (deg)
% Column 12:    Gait Cycle Counter                  (integer)
% Column 13:    Frame of Last Heel-Strike Event     (integer)
% Column 14:    Desired Stiffness of Treadmill      (N/m)

% Now, we append each one of the Vicon data columns as a new column for the
% final .csv file (table format)
temp = table([{'Treadmill Speed'}; {'cm/s'}; cellstr(num2str(vst_data_final(:,3)))],'VariableNames',{'TS'});
vst_vicon_data = [vst_vicon_data temp];

temp = table([{'Linear Track Desired Position'}; {'cm'}; cellstr(num2str(vst_data_final(:,4)))],'VariableNames',{'LTDP'});
vst_vicon_data = [vst_vicon_data temp];

temp = table([{'Linear Track Current Position'}; {'cm'}; cellstr(num2str(vst_data_final(:,5)))],'VariableNames',{'LTCP'});
vst_vicon_data = [vst_vicon_data temp];

temp = table([{'Treadmill Inclination'}; {'deg'}; cellstr(num2str(vst_data_final(:,6)))],'VariableNames',{'TI'});
vst_vicon_data = [vst_vicon_data temp];

temp = table([{'Gait Cycle'}; {''}; cellstr(num2str(vst_data_final(:,12)))],'VariableNames',{'GC'});
vst_vicon_data = [vst_vicon_data temp];

temp = table([{'Frame of Last Heel Strike Event'}; {''}; cellstr(num2str(vst_data_final(:,13)))],'VariableNames',{'FLHSE'});
vst_vicon_data = [vst_vicon_data temp];

temp = table([{"Treadmill's Desired Stiffness"}; {'N/m'}; cellstr(num2str(vst_data_final(:,14)))],'VariableNames',{'TDS'});
vst_vicon_data = [vst_vicon_data temp];

% Store the final file that combines the VST with the Vicon data
writetable(vst_vicon_data,[folder '/' output_file_name]);
writetable(emg_data_final,[folder '/' output_file_name_emg]);
% save('myfolder/myfile.mat','x','y');
% xlswrite([folder '/' output_file_name_x], vst_vicon_data);
% writetable(vst_vicon_data,[folder '/' output_file_name_x]);
end
return
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************
% *************************************************************************************************

%% Verification
% Z-coordinate of the Left Heel Marker with missing frames
lhee_z_vst_nan = round(vst_data_sync_nan(:,11),5);

% Z-coordinate of the Left Heel Marker as recorded from Vicon (Unified Dataset)
lhee_z_vst_vicon = str2double(vst_vicon_data.Var35(3:end));

figure(1)
hold on;
plot(lhee_z_vst_vicon)
plot(lhee_z_vst_nan)
plot(str2double(vst_vicon_data.FLHSE(3:end)),lhee_z_vst_vicon(str2double(vst_vicon_data.FLHSE(3:end))),'mx')
title("VST-Vicon Comparison of the Vertical Position of the Left Heel Marker",'interpreter','latex')
legend('LHEE Vertical Position (Vicon)','LHEE Vertical Position with missing frames (VST)','VST Heel-Strike Events','interpreter','latex','Fontsize',14)
xlabel('Frames')
ylabel('Position (mm)')

function offline_heel_strikes = fvespa(lhee_vert,lhee_sag,frames)
%% Heel-strike Detection (FVESPA)
%Custom Algorithm FVESPA - Real-time Implementation
%find for each gait cycle the global minimum and consider that heel strike
%occured in the exactly next frame.
%renew the global minimum everytime you find the global maximum and vice
%versa.

% Fixed parameters-variables for the 2nd-order Butterworth Filter
Fs = 100; % (Hz)
fc = 20; % (Hz)
omega_c = 2*pi*fc;
T = 1/Fs;
b1 = (omega_c*T)^2;
b2 = 2*(omega_c*T)^2;
b3 = (omega_c*T)^2;

a1 = 4 + 2*sqrt(2)*(omega_c*T) + (omega_c*T)^2;
a2 = -8 + 2*(omega_c*T)^2;
a3 = 4 - 2*sqrt(2)*(omega_c*T) + (omega_c*T)^2;

% Initialize the initial values for the filtering so that it can be
% applied even for the first sample
lhee_vert_raw_past = [0 0]; % Values of the raw signal at the last two samples ((k-1) (k-2))
lhee_vert_filt_past = [0 0]; % Values of the filtered signal at the last two samples ((k-1) (k-2))
lhee_sag_raw_past = [0 0]; % Values of the raw signal at the last two samples ((k-1) (k-2))
lhee_sag_filt_past = [0 0]; % Values of the filtered signal at the last two samples ((k-1) (k-2))

y_filt_vert = []; % Vector to store the filtered values of the vertical position of the left heel marker
y_filt_sag = []; % Vector to store the filtered values of the sagittal position of the left heel marker

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Initialization for the FVESPA
min_lhee=-1000; %Vertical component (in this case Y) of the LHEE marker
flag=0;
flag2=1;
mins=[];
maxs=[];
vel_prev_1=0;
vel_prev_2=0;
vel_prev_3=0;
computed_heel_strikes=[];
local_minima_fvespa = [];
sagittal_velocity = [];
lhee_sag_filtered = [];

iter_count = 1;
while(1) % Run loop forever until the experiment is over
%     if (iter_count ~= 
    % Load new-fresh samples of the desired markers
    %The Left Heel marker will be utilized
    lhee_vert_new = lhee_vert(iter_count); %Y axis of Left Heel Marker (motion on the vertical plane)
    lhee_sag_new = lhee_sag(iter_count); %X axis of Left Heel Marker (motion in the sagittal plane)
    % This will change in the future and the data will arrive sample by sample
    
    %We decide to use a 2nd order low pass butterworth filter at
    %cutoff 20Hz. The corresponding filter parameters were calculated in
    %the beginning. Since a 2nd order filter is applied, the last two
    %samples of both the raw and filtered signals are required.
    
    % Apply the filter to the vertical position of the left heel marker
    lhee_vert_new_f=(b1*lhee_vert_new + b2*lhee_vert_raw_past(1) + b3*lhee_vert_raw_past(2) - a2*lhee_vert_filt_past(1) - a3*lhee_vert_filt_past(2) )/a1;
    
    
    % Apply the filter to the sagittal position of the left heel marker
    lhee_sag_new_f=(b1*lhee_sag_new + b2*lhee_sag_raw_past(1) + b3*lhee_sag_raw_past(2) - a2*lhee_sag_filt_past(1) - a3*lhee_sag_filt_past(2) )/a1;
    
    lhee_sag_filtered = [lhee_sag_filtered; lhee_sag_new_f];
    %% Apply the FVESPA algorithm
    
    %in the implementation of the proposed code on the data from STAR, the Y
    %axis was defined in a way, where as that foot was moving forward, the Y
    %axis was decreasing. Hence, just before heel strike, as the foot is moving
    %backwards, the derivative of Y was increasing. In this dataset, the
    %forward axis is X and as the leg is moving backwards just before heel
    %strike, the X coordinate is decreasing and hence its derivative is
    %negative.
    vel_z = lhee_vert_new_f - lhee_vert_filt_past(1); %lhee_vert_f(k)-lhee_vert_f(k-1);
    vel_s = lhee_sag_new_f - lhee_sag_filt_past(1); %velocity in the sagittal plane (used to be vel_y in STAR dataset implementation)
    sagittal_velocity = [sagittal_velocity; vel_s];
    if vel_z>=0 && vel_prev_1<=0 && vel_prev_2<=0 && vel_prev_3<=0 && flag2==0
        local_minima_fvespa = [local_minima_fvespa iter_count];
        if vel_s>=-14 && lhee_vert_new_f<150% Necessary for Vicon H.S. % Originally -14
            %Fukuchi Dataset: vel_s<0
            % Here a new heel-strike was detected!!!
            min_lhee=lhee_vert_filt_past(1);
            %This was modified to stress that although we want to detect global minima, this detection has a delay of one frame
            computed_heel_strikes=[computed_heel_strikes,frames(iter_count)];%This was modified to stress that although we want to detect global minima
            flag2=1;
        end
    elseif iter_count>2 && vel_z<0 && vel_prev_1<=0 && vel_prev_2>=0 && ge(vel_prev_3,0) && ((lhee_vert_filt_past(2)-min_lhee)>100)
        maxs=[maxs; iter_count-2];
        flag2=0;
    end
    vel_prev_3=vel_prev_2;
    vel_prev_2=vel_prev_1;
    vel_prev_1=vel_z;
    %%% End of FVESPA algorithm for this iteration
    
    % Update the past samples vectors (raw and filtered) for the next incoming sample
    lhee_vert_raw_past = [lhee_vert_new lhee_vert_raw_past(1)];
    lhee_vert_filt_past = [lhee_vert_new_f lhee_vert_filt_past(1)];
    % Append the new filtered value into the total one for post processing
    y_filt_vert = [y_filt_vert lhee_vert_new_f];
    
    % Update the past samples vectors (raw and filtered) for the next incoming sample
    lhee_sag_raw_past = [lhee_sag_new lhee_sag_raw_past(1)];
    lhee_sag_filt_past = [lhee_sag_new_f lhee_sag_filt_past(1)];
    % Append the new filtered value into the total one for post processing
    y_filt_sag = [y_filt_sag lhee_sag_new_f];
    
    iter_count = iter_count + 1;
    if iter_count > length(lhee_vert)
        break
    end
end
offline_heel_strikes = computed_heel_strikes;
end